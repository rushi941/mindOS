import { mutation } from "./_generated/server";
import { REPORT_MODULES } from "../config/reportModules";
import { v } from "convex/values";

const ORGS = [
  { orgId: "org-1", orgName: "Northwind Labs" },
  { orgId: "org-2", orgName: "Helix Industries" },
  { orgId: "org-3", orgName: "Nova Collective" },
];

const VALUE_VECTORS = [
  "Bias to action; customer intimacy; radical candor; measure what matters; resilience in adversity.",
  "Craft and quality; build with users; calm focus; default to open; celebrate learning loops.",
  "Operational excellence; service mindset; kindness; reliability; disciplined process ownership.",
  "Learning velocity; safety to experiment; shared accountability; transparency by default.",
  "Strategic clarity; disciplined prioritisation; partnership mindset; evidence-based decisions.",
];

const NARRATIVES = [
  "The team is ambitious with strong execution muscle, experimenting rapidly but feeling tension between short-term targets and longer-term positioning.",
  "A dependable crew with calm focus; they show caution around launch risk which slows velocity but maintain high craft standards.",
  "Service-oriented operators absorbing tool churn, creating fatigue; they remain the cultural glue yet need clearer escalation pathways.",
  "Product-minded collaborators who ideate well but need stronger delivery rhythms and clearer leadership priorities.",
  "Cross-functional group with rising innovation energy, yet role clarity and handoff rituals lag behind ambition.",
];

function randomMindsetScores() {
  const ids = ["growth", "stability", "agility", "cohesion", "experimentation", "resilience", "clarity"];
  const names = ["Growth", "Stability", "Agility", "Cohesion", "Experimentation", "Resilience", "Clarity"];
  return ids.map((id, idx) => {
    const base = 55 + (idx * 7) % 20;
    return {
      mindsetId: id,
      mindsetName: names[idx],
      capacity: Math.min(95, base + Math.floor(Math.random() * 20)),
      friction: Math.max(15, 30 + Math.floor(Math.random() * 25)),
    };
  });
}

function makeTeams() {
  const teams: any[] = [];
  ORGS.forEach((org) => {
    for (let i = 1; i <= 50; i++) {
      const idx = i % VALUE_VECTORS.length;
      teams.push({
        orgId: org.orgId,
        teamId: `${org.orgId}-team-${i}`,
        teamName: `${org.orgName} Team ${i}`,
        valuesVector: VALUE_VECTORS[idx],
        aggregatedNarrative: NARRATIVES[idx],
        mindsetScores: randomMindsetScores(),
      });
    }
  });
  return teams;
}

export const seedAll = mutation({
  args: {
    orgs: v.optional(
      v.array(
        v.object({
          orgId: v.string(),
          orgName: v.string(),
        }),
      ),
    ),
    teams: v.optional(
      v.array(
        v.object({
          orgId: v.string(),
          teamId: v.string(),
          teamName: v.string(),
          valuesVector: v.string(),
          aggregatedNarrative: v.string(),
          mindsetScores: v.array(
            v.object({
              mindsetId: v.string(),
              mindsetName: v.string(),
              capacity: v.number(),
              friction: v.number(),
            }),
          ),
        }),
      ),
    ),
  },
  handler: async (ctx, args) => {
    // Use provided data or generate default seed data
    const orgs = args.orgs ?? ORGS;
    const teams = args.teams ?? makeTeams();
    let orgsInserted = 0;
    let teamsInserted = 0;

    for (const org of orgs) {
      const existing = await ctx.db
        .query("organizations")
        .withIndex("by_orgId", (q: any) => q.eq("orgId", org.orgId))
        .first();
      if (!existing) {
        await ctx.db.insert("organizations", org);
        orgsInserted += 1;
      }
    }

    for (const team of teams) {
      const existingTeam = await ctx.db
        .query("teams")
        .withIndex("by_teamId", (q: any) => q.eq("teamId", team.teamId))
        .first();
      if (!existingTeam) {
        await ctx.db.insert("teams", team);
        teamsInserted += 1;
      }
    }

    // Seed a minimal placeholder report per team if none exists
    for (const team of teams) {
      const existingReport = await ctx.db
        .query("reports")
        .withIndex("by_team_created", (q: any) => q.eq("teamId", team.teamId))
        .order("desc")
        .first();
      if (!existingReport) {
        await ctx.db.insert("reports", {
          teamId: team.teamId,
          createdAt: Date.now(),
          version: "seed",
          modules: REPORT_MODULES.map((m) => m.id),
          markdown: `# Seed Report for ${team.teamName}\n\nThis is a placeholder report generated by the seed script.\n\nModules: ${REPORT_MODULES.map((m) => m.title).join(", ")}`,
        });
      }
    }

    return { orgsInserted, teamsInserted };
  },
});
